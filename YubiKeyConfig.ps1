# Function to check if a YubiKey is inserted and return its serial number
function Get-YubiKeySerial {
    $output = .\ykman.exe list
    if ($output -match 'Serial:\s*(\d+)') {
        return $matches[1]
    }
    return $null
}

# Function to set the YubiKey lock code and return its value
# Remove via .\ykman.exe config set-lock-code -c
function Set-LockCode {
    # Configure the YubiKey with a new lock code, randomly generated by the ykman utility
    $output = .\ykman.exe config set-lock-code --generate -f

    # Print the output to the console
    Write-Host "YubiKey Configuration Lock Code:" $output -ForegroundColor Red

    # Extract the lock code from the output using regex, and write it to the configuration hashtable
    $CurrentLockCode = ($output | Select-String -Pattern "[a-z0-9]{10,}").Matches.Value
    $CurrentYubiKeyConfiguration.add("KeyConfigurationLockCode", $CurrentLockCode)

}


# Function to configure the YubiKey
function Configure-YubiKey {
    .\ykman.exe config usb --disable U2F -f
    .\ykman.exe config usb --disable OATH -f
    .\ykman.exe config usb --disable PIV -f
    .\ykman.exe config usb --disable OPENPGP -f
    .\ykman.exe config usb --disable HSMAUTH -f
    
    .\ykman.exe config nfc --disable OTP -f
    .\ykman.exe config nfc --disable OATH -f
    .\ykman.exe config nfc --disable U2F -f
    .\ykman.exe config nfc --disable PIV -f
    .\ykman.exe config nfc --disable OPENPGP -f
    .\ykman.exe config nfc --disable HSMAUTH -f

    # Add more configuration commands as needed
}


# Function to configure the Yubikey for OTP in FIPS Level 2 Mode
# https://docs.yubico.com/hardware/yubikey/yk-tech-manual/fips-specifics.html#otp-deployment
# Remove access codes via .\ykman.exe otp --access-code [OTPAccessCode] settings --delete-access-code 1
function Set-OTPFIPS{

    # Run the ykman command and capture output
    $ykmanOutput = & .\ykman.exe otp info

    # Variables to track slot status
    $slot1Empty = $false
    $slot2Empty = $false

    # Process each line and check for slot status
    foreach ($line in $ykmanOutput) {
        if ($line -match "Slot 1: empty") { $slot1Empty = $true }
        if ($line -match "Slot 2: empty") { $slot2Empty = $true }
    }

    # Output results based on detected slot states, if the slot is empty, configure with the default OTP configuration which is required for an Access Code to be applied
    if ($slot1Empty -and $slot2Empty) {
        Write-Host "Both OTP slots are empty."
    } 
    elseif ($slot1Empty) {
        Write-Host "Slot 1 is empty, applying default OTP configuration."
        .\ykman.exe otp chalresp --generate 1 -f
    } 
    elseif ($slot2Empty) {
        Write-Host "Slot 2 is empty, applying default OTP configuration."
        .\ykman.exe otp chalresp --generate 2 -f
    } 
    else {
        Write-Host "Both OTP slots are programmed, proceeding with FIPS configuration"
    }

    # Generate a 6-byte random code
    $randomBytes = New-Object byte[] 6
    [Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($randomBytes)

    # Convert the bytes to a hexadecimal string
    $OTPAccessCode = ($randomBytes | ForEach-Object { $_.ToString("X2") }) -join ""

    # Output the hexadecimal code, and save to the configuration hashtable
    Write-Host "OTP ACCESS CODE: $OTPAccessCode" -ForegroundColor Red
    $CurrentYubiKeyConfiguration.add("OTPAccessCode",  $OTPHexCode)

    # Configure the kewykey with the access code
    .\ykman.exe otp settings 1 --new-access-code=$OTPAccessCode -f | Out-Null
    .\ykman.exe otp settings 2 --new-access-code=$OTPAccessCode -f | Out-Null

    return $OTPAccessCode
}

# Function to configure the Yubikey for OATH in FIPS Level 2 Mode
# https://docs.yubico.com/hardware/yubikey/yk-tech-manual/fips-specifics.html#oath-fips-140-2-with-yubikey-5-fips-series
function Set-OATHFIPS{
    
    # Run the ykman command and capture output
    $ykmanOutput = & .\ykman.exe oath info

    # Process each line and check for slot status
    foreach ($line in $ykmanOutput) {
        if ($line -match "Password protection: disabled") { $oathPasswordProtection = $false }
    }

    if ($oathPasswordProtection -eq $false) {

        # Generate a 6-byte random code
        $randomBytes = New-Object byte[] 6
        [Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($randomBytes)

        # Convert the bytes to a hexadecimal string
        $OATHAccessCode = ($randomBytes | ForEach-Object { $_.ToString("X2") }) -join ""
        
        # Output the OATH code, and save to the configuration hashtable
        Write-Host "OATH ACCESS CODE: $OATHAccessCode" -ForegroundColor Red
        $CurrentYubiKeyConfiguration.add("OATHAccessCode",  $OATHAccessCode)

        # Configure the Yubikey with the OATH access code
        .\ykman.exe oath access change -n $OATHAccessCode

    } 
    else {
        Write-Host "OATH password protection is already enabled."
    }

    return $OATHAccessCode

}

# Function to configure the Yubikey for WebAuthN in FIPS Level 2 Mode
# https://docs.yubico.com/hardware/yubikey/yk-tech-manual/fips-specifics.html#oath-fips-140-2-with-yubikey-5-fips-series
function Set-WebAuthNFIPS{
    
    # Configure the minimum PIN length for WebAuthn, based upon NIST SP 800-63B A.4
    .\ykman.exe fido access set-min-length 8 -f

    # Generate a 4-byte random code
    $randomBytes = New-Object byte[] 4
    [Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($randomBytes)
    $WebAuthnPIN = [BitConverter]::ToUInt32($randomBytes, 0) % 90000000 + 10000000
        
    # Output the WebAuthN PIN, and save to the configuration hashtable
    Write-Host "WEBAUTHN PIN: $WebAuthnPIN" -ForegroundColor Red
    $CurrentYubiKeyConfiguration.add("WebAuthNPIN",  $WebAuthnPIN)

    # Configure the Yubikey with the OATH access code
    .\ykman.exe fido acces change-pin -n $WebAuthnPIN -f

    # Disable U2F over NFC and USB for WebAuthN
    # https://docs.yubico.com/hardware/yubikey/yk-tech-manual/fips-specifics.html#u2f
    .\ykman.exe config usb -dU2F -f
    .\ykman.exe config nfc -dU2F -f

}

# Function to configure the Yubikey for WebAuthN in FIPS Level 2 Mode
# https://docs.yubico.com/hardware/yubikey/yk-tech-manual/fips-specifics.html#oath-fips-140-2-with-yubikey-5-fips-series
function Set-PIVFIPS{

    # Check the Yubikey firmware version, and if it is equal to or greater than 5.4.0, configure the PIV application
    $output = & .\ykman.exe info

    # Extract the firmware version using regex
    $firmwareVersion = [System.Version]($output | Select-String -Pattern "\d\.\d\.\d+").Matches.Value

    # If the firmware version is 5.4.0 or greater, configure the management key for PIV using AES256
    if ($firmwareVersion -ge [System.Version]"5.4.0") {
         
        $ykmanOutput =  .\ykman.exe piv access change-management-key -m 010203040506070801020304050607080102030405060708 -g -a AES256 -f
        Write-Host $ykmanOutput -ForegroundColor Red

    } else {
        
        $ykmanOutput =  .\ykman.exe piv access change-management-key -m 010203040506070801020304050607080102030405060708 -g -f
        Write-Host $ykmanOutput -ForegroundColor Red

    }

    $PIVManagementKey = ($ykmanOutput| Select-String -Pattern "[a-z0-9]{12,}").Matches.Value
    $CurrentYubiKeyConfiguration.add("PIVManagementKey",  $PIVManagementKey)


    # Generate a 4-byte random code
    $randomBytes = New-Object byte[] 4
    [Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($randomBytes)
    $PIVPIN = [BitConverter]::ToUInt32($randomBytes, 0) % 90000000 + 10000000
        
    # Output the WebAuthN PIN, and save to the configuration hashtable
    Write-Host "PIV PIN: $PIVPIN" -ForegroundColor Red
    $CurrentYubiKeyConfiguration.add("PIVPIN",  $PIVPIN)

    # Configure the Yubikey with the OATH access code
    .\ykman.exe piv access change-pin -P 123456 -n $PIVPIN


    # Generate a 4-byte random code
    $randomBytes = New-Object byte[] 4
    [Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($randomBytes)
    $PIVPUKPIN = [BitConverter]::ToUInt32($randomBytes, 0) % 90000000 + 10000000
        
    # Output the WebAuthN PIN, and save to the configuration hashtable
    Write-Host "PIV PUK PIN: $PIVPUKPIN" -ForegroundColor Red
    $CurrentYubiKeyConfiguration.add("PIVPUKPIN",  $PIVPUKPIN)

    # Configure the Yubikey with the OATH access code
    .\ykman.exe piv access change-puk -p 12345678 -n $PIVPUKPIN 

}

# Main script loop
$previousSerial = $null

while ($true) {
    Write-Host "Please insert a YubiKey..."
    
    # Wait for a new YubiKey to be inserted
    while ($true) {
        $currentSerial = Get-YubiKeySerial
        if ($currentSerial -and $currentSerial -ne $previousSerial) {
            $previousSerial = $currentSerial
            break
        }
        Start-Sleep -Seconds 1
    }
    
    Write-Host "YubiKey detected (Serial: $currentSerial). Configuring..."

    $CurrentYubiKeyConfiguration = @{}  # Initialize an empty hashtable
    $CurrentYubiKeyConfiguration.add("SerialNumber", $currentSerial)
    
    

    Set-OTPFIPS
    
    Set-OATHFIPS

    Set-WebAuthNFIPS

    Set-PIVFIPS

    Configure-YubiKey
    
    Set-LockCode

    $CurrentYubiKeyConfiguration | ForEach-Object{ [pscustomobject]$_ } | Export-Csv -Path $Env:USERPROFILE\Documents\YubiKeyConfiguration.csv -Force -Append
    

    Write-Host "Configuration complete. Please remove the YubiKey."
    
    # Wait for the YubiKey to be removed
    while ($true) {
        $currentSerial = Get-YubiKeySerial
        if (-not $currentSerial) {
            break
        }
        Start-Sleep -Seconds 1
    }
}
